#!/usr/bin/perl -w
# -*- Mode: CPerl -*-
#
#  This code was developped by IDEALX (http://IDEALX.org/) and
#  contributors (their names can be found in the CONTRIBUTORS file).
#  Copyright (C) 2000-2004 IDEALX
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

# Version: $Id$

# purpose: quick and dirty ugly hack to compute stats and plots graph
# given a (set of) log file(s)  from the IDX-Tsunami tool.


use strict;
use Getopt::Long;
use vars qw ($help @files $verbose $debug $plot $extra $version $stats);
my $tagvsn = '%VSN%';

GetOptions( "help",\$help,
			"verbose",\$verbose,
			"debug",\$debug,
			"stats=s",\$stats,
			"version",\$version,
			"plot",\$plot,
			"extra",\$extra
		  );

&usage if $help or $Getopt::Long::error or not $stats;
&version if $version;


my $gnuplot = "gnuplot >> gnuplot.log 2>&1";

&parse_stats_file($stats);

# plot stats from file
sub plot_stats {
	# args:
	my $title     = shift; # arrayref contaning data titles
	my $datatype  = shift; # type of data (added in filenames)
	my $timestamp = shift;
	my $files     = shift; # arrayref contaning data files
	my $ylabel    = shift;

	# local var
	my $style       = "linespoint"; # TODO: can be override in option
	my $legend_loc  = "key right top"; # TODO: can be override in option
	my $output_type = "postscript color"; # TODO: can be override in option
	my $filename; # temporary var

	$datatype = "unknown" unless $datatype;
	open(GP,">graphes-$datatype.gplot") or die "can't open graphes-$datatype.gplot: $!";
	select GP;

	# gnuplot styles and options
	print "set data style $style\n";
	print "set terminal $output_type\n";
	print "set output \"graphes-$datatype.ps\"\n";
	print "set grid\n";
	
	my $d; # temporary var (title)
	foreach $d (0..$#{$title}) {
		# gnuplot headings
		print "set title \" @{$title}[$d]\"\n";
        if ($timestamp) {
            print "set xlabel \"unit = $timestamp sec \"\n";
        } else {
            print "set xlabel \"unit = sec \"\n";
        }
		print "set ylabel \"".$ylabel->[$d]."\"\n" if $ylabel->[$d];
		print "show title\n";
		print "set $legend_loc\n";

		print "plot ";
		foreach $filename (@{$files}) {
			print " \"$filename\" using ";
			# if $timestamp isn't defined, use the first column as timestamp
			if ($timestamp) {
				print $d+1 ;
			} else {
				print " 1:" .($d+2);
			}
			print " title \"$filename\"" ;
			print "," unless ($filename eq @{$files}[$#{$files}]); # unless last occurence
		}
		print "\n"; # plot done
	}
	close GP;
	system("$gnuplot graphes-$datatype.gplot");
}

sub max {
	my $value   = shift;
	my $oldvalue= shift;
	return $value unless $oldvalue;
	return $value if $oldvalue < $value;
	return $oldvalue;
}

sub parse_stats_file {
	my $file = shift;
	my $data;
	my $timestamp;
	my $first_timestamp =0;
	my $first_interval =0;
	my $interval;

	my $maxval ;
	open (FILE,"<$file") or die "Can't open $file $!";
	while (<FILE>) {
		if (/^stats: (\S+)\s+(.*)$/) {
			my $type = $1;
			my $values = $2;
			my ($rate,$mean) = split(/\s+/,$values);
			if ($interval) {
				$rate /= $interval;
				$maxval->{'rate'}->{$type} = &max($rate, $maxval->{'rate'}->{$type});
				$maxval->{'mean'}->{$type} = &max($mean, $maxval->{'mean'}->{$type});
			}
			push @{$data->{$type}}, $timestamp . " ". $values;
		} elsif (/^\# stats:\s+dump at\s+(\d+)/) {
			$first_timestamp= $1 unless $first_timestamp;
			$interval = ($timestamp) ? $timestamp : 0; # keep previous value
			$timestamp = $1 - $first_timestamp;
			$interval = $timestamp-$interval;
			$first_interval= $interval if $interval and not $first_interval;
		}
	}
	close FILE;
	foreach my $key (sort keys %{$maxval->{'rate'}}) {
		if ($key =~ /\d+/ or $key eq 'size') {
			printf "Total $key = %7.2f\n", $maxval->{'mean'}->{$key};
		} else {
			printf "Mean  $key (max sample) = %7.2f\n", $maxval->{'mean'}->{$key};
		}
		printf "Rate  $key (max sample) = %7.2f\n",$maxval->{'rate'}->{$key};
	}
	my @time;
	my @tps;
	my @code;
    my %extra_info = ();
	my @connect;
	my @size;
	my @users;
	my @users_rate;
	my @transactions;
	my $key;
    if ($interval != $first_interval) {
        print "warn, last interval ($interval) not equal to the first, use the first one ($first_interval)\n";
        $interval=$first_interval;
    }
	my @col = ("rate","mean","stdvar","max sample","min sample");
	my @colcount = ("rate","total");
	my @colusers = ("simultaneous","maximum simultaneous");
	foreach $key (keys %{$data}) {
        $key =~ s/\'//g;
		open (TYPE, "> $key.txt") or die "$!";
		foreach my $data (@{$data->{$key}}) {
			if (($key !~ /^users$/ and $key !~ /^size$/) and $interval) {#
				my @tmp;
				my $time;
				($time, $data, @tmp) = split(/\s/,$data);
				$data /= $interval;
				$data = "$time $data @tmp";
			} elsif ($key =~ /size/) { # bits instead of bytes
				my ($time, @tmp) = split(/\s/,$data);
				@tmp = map {$_*8/(1024*$interval) } @tmp; # kb/s instead of Bytes/s
				$data = "$time @tmp";
			}
			print TYPE $data ."\n";
		}
		if ($key eq "session" or $key eq "reconnect" or $key eq "connect") {
			push @connect, "$key.txt";
		} elsif ($key eq "size") {
			push @size, "$key.txt";
		} elsif ($key =~ /^users$/) {
			push @users, "$key.txt";
		} elsif ($key =~ /users/) {
			push @users_rate, "$key.txt";
		} elsif ($key =~ /response_time$/) {
			push @tps, "$key.txt";
		} elsif ($key =~ /^tr_/ or $key eq "page_resptime") {
			push @transactions, "$key.txt";
		} elsif ($key =~ /^\d+$/) {
			push @code, "$key.txt";
		} elsif ($key =~ /^(\S+)?:\S+?@\S+$/) {
            my $key_short_name = $1;
            push(@{$extra_info{$key_short_name}}, "$key.txt");
		} else {
			push @time, "$key.txt";
		}
		close TYPE;
	}
	plot_stats(\@col,"Session",undef,\@connect,["sessions/sec"]) if $plot;
	plot_stats(\@colcount,"HTTP_CODE",undef,\@code,["number/sec","total"]) if $plot;
	plot_stats(\@col,"Perfs",undef,\@tps,["rate/sec","msec"]) if $plot;
	plot_stats(\@col,"Transactions",undef,\@transactions,["rate/sec","msec"]) if $plot;
	plot_stats(\@col,"Event",undef,\@time,["rate/sec","msec"]) if $plot;
	plot_stats(\@colusers,"Users",undef,\@users,["connected users", "total"]) if $plot;
	plot_stats(\@col,"Users_Arrival",undef,\@users_rate,["number of users/sec", "total"]) if $plot;
	plot_stats(\@colcount,"Size",undef,\@size,["Kbits/sec","total Kbits"]) if $plot;

    # Generate graphes for extra indicators (os_mon for example)
	if ($plot and $extra) {
 	  foreach my $key (sort keys %extra_info) {
          my $pos = index($key,":");
          plot_stats(\@col, $key, undef, \@{$extra_info{$key}}, [$key]);
      }
  }
}

sub usage {
	print "this script is part of IDX-TSUNAMI version $tagvsn,
Copyright (C) 2001 IDEALX (http://IDEALX.org/)\n\n";
	print "IDX-TSUNAMI comes with ABSOLUTELY NO WARRANTY; This is free software, and
ou are welcome to redistribute it under certain conditions
type `idx-tsunami.pl --version` for details.\n\n";

    print "Usage: $0 [<options>]\n","Available options:\n\t",
    "[--help] (this help text)\n\t",
    "[--verbose] (print all messages)\n\t",
    "[--debug] (print receive without send messages)\n\t",
    "[--plot]  (make postcripts graphics using gnuplot)\n\t",
    "[--extra  (generate graphics from extra cluster data (os monitor, etc)\n\t",
    "[--stats <file>] (stats file to analyse)\n\t";
	exit;
	}

sub	affiche() {
	my $name = shift;
	my $value = shift;
	return sprintf "#%7s = %.3f",$name,$value;
}

sub version {
print "this script is part of IDX-TSUNAMI version $tagvsn

Written by Nicolas Niclausse and Jean François Lecomte

Copyright (C) 2001-2004 IDEALX (http://IDEALX.org/)

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program (see COPYING); if not, write to the 
Free Software Foundation, Inc., 59 Temple Place - Suite 330, 
Boston, MA 02111-1307, USA.";
exit;
}
