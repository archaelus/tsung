#! /usr/bin/perl -w
# -*- Mode: CPerl -*-
#
#  This code was developped by IDEALX (http://IDEALX.org/) and
#  contributors (their names can be found in the CONTRIBUTORS file).
#  Copyright (C) 2000-2001 IDEALX
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

#  Created by : Nicolas Niclausse <nniclausse@idealx.com>

my $vsn = '$Id$ ';
my $tagvsn = '%VSN%';

use strict;
use POSIX;
use Getopt::Long;
use vars qw /$help $start $restart $config $stop $stopcontrol $version/;

my $erl = "erl";
my $ssh = "ssh -x";
my $scp = "scp ";
my %config;

my $rootdir = "/usr/local/idx-tsunami";
my $utilsdir = $rootdir . "/etc";
my $rcfile = $utilsdir . "/idx-tsunamirc";

my $controller_up = 0; # true if the controller is started
my ($nbeams, $ndeb, $nfin);
my $monitor ;
my $nodename ;
my $maxclients = 1000 ;
my $range = 2000 ;
my $nfirst = 0 ;
my $totalclient = 0 ;
my $currentclient = 0 ;
my ($key,$nmachines,$interarrival) ; # tocheck
my (@hosts);
my ($debug,$appfile,$cookie);
my @servers;
my $server_id=0;

GetOptions( "h|help",\$help,
			"start",\$start,
			"restart",\$restart,
			"config",\$config,
			"version",\$version,
			"stop",\$stop,
			"stopcontrol",\$stopcontrol
		  );

&usage if ($help);
&version if ($version);


if ($config or $start or $restart) {
	&read_rc;

	print "Config: $totalclient clients will be launched from $nmachines machines ($nbeams beams per machine)\n";
	my $session_duration = $config{'messages_number'}*$config{'messages_interarrival'}/60;
	my $launching_duration = $interarrival*$totalclient/60;
	print "Estimated minimum duration  : ". POSIX::ceil($session_duration+$launching_duration) ." mn\n" ;
	print "single session min duration : ". POSIX::ceil($session_duration) ." mn\n" ;
	print "last client will be launched after : ". POSIX::ceil($launching_duration) ." mn\n" ;

	my $j=0;
	foreach my $host (@hosts) {
		foreach my $i ($j..$j+$nbeams-1)  {
			$ndeb = $nfirst + $i*$range ;
			$nfin = $nfirst + ($i+1)*$range - 1;
			$currentclient += $config{'nclients'};
			if ($currentclient > $totalclient) {
				# remove exceeding client (caused by ceiling)
				$config{'nclients'} -= ($currentclient - $totalclient);
			}
			# create .config file
			$appfile = "$rootdir/etc/tsunami$i.config";
			open (APP,">$appfile") or die("Impossible d'ouvrir le fichier $appfile");
			select APP;
			print "[";
			foreach my $appname ("tsunami_controller", "tsunami") {
				print "{$appname,
  [\n";
				foreach $key (sort keys %config) {
					if ($key eq "server_adr") {
						# if multiple servers are set, we choose one using a
						# round robin algorithm
						@servers = split(/:/,$config{$key});
						print "{$key, \"". $servers[$server_id] . "\"},\n";
						$server_id = ($server_id + 1) % ($#servers+1) ;
					} elsif ($key eq "nclients" and $appname ne "tsunami") {
						print "{$key, ". $totalclient . "},\n";
					} else {
						# if contains  ':' ,'.' or '-' , put quotes, otherwise,
						# Erlang is not happy
						if (($config{$key} =~ /[:|-|\.]/) and ($config{$key} !~ /^\d+\.\d+$/) or $key eq "http_version"){
							print "{$key, \"". $config{$key} . "\"},\n";
						}
						else {
							print "{$key, ". $config{$key} . "},\n";
						}
					}
				}
				if ($appname ne "tsunami") {
					print "{nclients_deb, ". 0 . "},\n";
					print "{nclients_fin, ". $nbeams*$nmachines*$range . "},\n";
				} else {
					print "{nclients_deb, ". $ndeb . "},\n";
					print "{nclients_fin, ". $nfin . "},\n";
				}
				if ($config{'client_type'} =~ /dynamic/) {
					print "{mes_type, dynamic}\n";
				} else {
					print "{mes_type, static}\n";
				}
				print "  ] }\n";
				print "  ,\n" if $appname ne "tsunami";
				
			}
			print "].\n";
			close APP ;
			select STDOUT;
			if ($start and not $config) {
				$nodename = "tsunami$i";
				print "launching Beam $nodename on host $host\n";
				unless ($config{'nfs'} or $host eq "localhost") {
					print "copying config file to remote host ...\n";
					system("$scp $appfile $host:$appfile");
				}
				if ($host eq "localhost") {
					print "$erl -name $nodename -setcookie \'$config{'cookie'}\' -detached -boot $rootdir/bin/tsunami -boot_var TSUNAMIPATH $rootdir/erlang -config $rootdir/etc/tsunami$i\.config\n" ;
					system("$erl -name $nodename -setcookie \'$config{'cookie'}\' -detached -boot $rootdir/bin/tsunami -boot_var TSUNAMIPATH $rootdir/erlang -config $rootdir/etc/tsunami$i\.config" ) ;#and die "system failed: $?" ;
				}
				else {
					print "$ssh $host \" $erl -name $nodename -setcookie \'$config{'cookie'}\' -detached -boot $rootdir/bin/tsunami -boot_var TSUNAMIPATH $rootdir/erlang -config $rootdir/etc/tsunami$i\.config\"\n" ;
					system("$ssh $host \" $erl -name $nodename -setcookie \'$config{'cookie'}\' -detached -boot $rootdir/bin/tsunami -boot_var TSUNAMIPATH $rootdir/erlang -config $rootdir/etc/tsunami$i\.config\"" ); # and die "system failed: $?" ;
				}
			}
		}
		$j += $nbeams;
	}
	sleep (5);
	if (($start or $restart) and not $config and not $controller_up) {
		&start_controller();
		$controller_up = 1;
	}
	
} elsif ($stop) {
	&read_rc;
	&stop;
} elsif ($stopcontrol) {
	&read_rc;
	&stopcontrol;
} else {
	print "Nothing to do ... aborting (try --help)\n";
}

sub start_controller {
	# start the controller on the current host
	my $cmd;
	if ($config{"controller"} eq "localhost") {
		$cmd = "$erl -name controller -setcookie \'$config{'cookie'}\' -detached -boot $rootdir/bin/tsunami_controller -boot_var TSUNAMIPATH $rootdir/erlang -config $rootdir/etc/tsunami0\.config";
	} else {
		$cmd = "ssh $config{controller} \"$erl -name controller -setcookie \'$config{'cookie'}\' -detached -boot $rootdir/bin/tsunami_controller -boot_var TSUNAMIPATH $rootdir/erlang -config $rootdir/etc/tsunami0\.config\"";
		
	}
	print "$cmd\n" ;
	system("$cmd" ) ;
}

sub read_rc {
	my $value;
	my $name;
	
	open (RC,"<$rcfile") or die("Impossible d'ouvrir le fichier $rcfile");
	while (<RC>) {
		next if /^\#/; #remove comments
		if (/(\w+)\s*=\s*([^\n]+)\n/) {
			$value = $2;
			$value =~ s/\"//g;
			$name = lc($1);
			$config{$name} = $value;
		}
	}

	$totalclient = $config{'nclients'}; 
	$nmachines = ($config{'machines'} =~ tr/:/:/) +1; # TODO
	$nbeams = POSIX::ceil($config{'nclients'}/($nmachines*$maxclients));
	$config{'nclients'} = POSIX::ceil($config{'nclients'}/($nmachines*$nbeams));
	$interarrival = $config{'interarrival'};
	$config{'interarrival'} = $interarrival *($nbeams*$nmachines);

	
	@hosts = split (/:/,$config{'machines'});
}

sub stop {
	# apply function application:stop() by rpc
	my @hostnames;
	foreach my $host (@hosts) {
		if ($host =~ /localhost/) { # erlang beam use the real name, not localhost
			$host = `hostname`;
			chomp $host;
		}
		push @hostnames, $host;
	}
	my @args = ("tsunami");
	&rpc_node(1,"application","stop",\@args,\@hostnames);
}

sub stopcontrol {
	my @args = ("tsunami_controller");
	my @hostnames = ("$config{'controller'}");
	&rpc_node(1,"application","stop",\@args,\@hostnames,"controller");
}

sub rpc_node {
	my $stop      = shift;
	my $module    = shift;
	my $function  = shift;
	my $args      = shift;
	my $hostnames = shift;
	my $nodename  = shift;
	my $verbose   = 1;
	my ($j,$sname);

	open(ERL,"| $erl -name rpcnode -setcookie $config{'cookie'} > /dev/null") or die "can't exec erl";
	print ERL "net_adm:world_list(\['". join("','", @$hostnames) . "'\]).\n";
	print "net_adm:world_list(\['". join("','", @$hostnames) . "'\]).\n" if $verbose;
	$j = 0;
	foreach my $host (@$hostnames) {
		if ($nodename) {
			$sname="$nodename\@$host";
				my $args = join(",
", @$args);
			&rpc($sname, $module, $function, $args, $stop, $verbose)
		} else {
			foreach my $i ($j..$j+$nbeams-1)  {
				$nodename = "tsunami$i";
				$sname="$nodename\@$host";
				my $args = join(",
", @$args);
				&rpc($sname, $module, $function, $args, $stop, $verbose)
			}
			$j += $nbeams;
		}
	}
	close ERL;
}

sub rpc {
	my $sname    = shift;
	my $module   = shift;
	my $function = shift;
	my $args     = shift;
	my $stop     = shift;
	my $verbose  = shift;
	print "rpc:cast(\'$sname\',$module,$function,\[". $args ."\]).\n" if $verbose;
	print ERL "rpc:cast(\'$sname\',$module,$function,\[". $args ."\]).\n";
	print ERL "slave:stop(\'$sname\').\n" if $stop;
	print "slave:stop(\'$sname\').\n" if $stop;
}

sub usage  {
	print "IDX-TSUNAMI version $tagvsn, Copyright (C) 2001 IDEALX (http://IDEALX.org/)\n\n";
	print "IDX-TSUNAMI comes with ABSOLUTELY NO WARRANTY; This is free software, and
ou are welcome to redistribute it under certain conditions
type `idx-tsunami.pl --version` for details.\n";
	print "\n";
	print "options: [--start]  start clients\n";
    print "       : [--restart] start only tsunami controller\n";
    print "       : [--stop]   stop clients\n";
    print "       : [--stopcontrol]   stop tsunami controller only \n";
    print "       : [--config] only generate config files\n";
    print "       : [-h]       help\n";
    exit;
}

sub version {
print "IDX-TSUNAMI version $tagvsn

Written by Nicolas Niclausse and Jean François Lecomte

Copyright (C) 2001 IDEALX (http://IDEALX.org/)

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program (see COPYING); if not, write to the 
Free Software Foundation, Inc., 59 Temple Place - Suite 330, 
Boston, MA 02111-1307, USA.";
exit;
}
